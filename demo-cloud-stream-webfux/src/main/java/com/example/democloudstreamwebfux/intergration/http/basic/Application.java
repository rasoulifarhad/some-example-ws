package com.example.democloudstreamwebfux.intergration.http.basic;

import java.util.Arrays;

import org.springframework.boot.ApplicationRunner;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.builder.SpringApplicationBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.annotation.Order;
import org.springframework.expression.ExpressionParser;
import org.springframework.expression.spel.standard.SpelExpressionParser;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.integration.annotation.IntegrationComponentScan;
import org.springframework.integration.dsl.IntegrationFlow;
import org.springframework.integration.dsl.IntegrationFlows;
import org.springframework.integration.gateway.MessagingGatewaySupport;
import org.springframework.integration.http.config.EnableIntegrationGraphController;
import org.springframework.integration.http.inbound.HttpRequestHandlingMessagingGateway;
import org.springframework.integration.http.inbound.RequestMapping;
import org.springframework.integration.http.support.DefaultHttpHeaderMapper;
import org.springframework.integration.mapping.HeaderMapper;
import org.springframework.messaging.Message;
import org.springframework.messaging.support.MessageBuilder;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestTemplate;

import com.example.democloudstreamwebfux.intergration.ChannelConfiguration;
import com.example.democloudstreamwebfux.intergration.ChannelConfiguration.TestStringChannels;

import lombok.extern.slf4j.Slf4j;


/**
 * HTTP Outbound Components
 * 
 * Using HttpRequestExecutingMessageHandler
 * 
 *   <bean id="httpOutbound"
 *     class="org.springframework.integration.http.outbound.HttpRequestExecutingMessageHandler">
 *     <constructor-arg value="http://localhost:8080/example" />
 *     <property name="outputChannel" ref="responseChannel" />
 *   </bean>
 * 
 * This bean definition runs HTTP requests by delegating to a RestTemplate. That template, in turn, delegates to a list of HttpMessageConverter instances to generate the HTTP request body from the Message payload. You can configure those converters as well as the ClientHttpRequestFactory instance to use, as the following example shows:
 * 
 *   <bean id="httpOutbound"
 *     class="org.springframework.integration.http.outbound.HttpRequestExecutingMessageHandler">
 *     <constructor-arg value="http://localhost:8080/example" />
 *     <property name="outputChannel" ref="responseChannel" />
 *     <property name="messageConverters" ref="messageConverterList" />
 *     <property name="requestFactory" ref="customRequestFactory" />
 *   </bean>
 * 
 * By default, the HTTP request is generated by using an instance of SimpleClientHttpRequestFactory, which uses the JDK HttpURLConnection. Use of the Apache Commons HTTP Client is also supported through CommonsClientHttpRequestFactory, which you can inject (as shown earlier).
 * 
 * For the outbound gateway, the reply message produced by the gateway contains all the message headers that are present in the request message. 
 * 
 * Using Cookies
 * 
 * Basic cookie support is provided by the transfer-cookies attribute on the outbound gateway. When set to true (the default is false), a Set-Cookie header received from the server in a response is converted to Cookie in the reply message. This header is then used on subsequent sends. This enables simple stateful interactions, such as the following:
 * 
 *     …​→logonGateway→…​→doWorkGateway→…​→logoffGateway→…​
 * 
 * If transfer-cookies is false, any Set-Cookie header received remains as Set-Cookie in the reply message and is dropped on subsequent sends.
 * 
 * Empty Response Bodies
 * 
 * HTTP is a request-response protocol. However, the response may not have a body, only headers. In this case, the HttpRequestExecutingMessageHandler produces a reply Message with the payload being an org.springframework.http.ResponseEntity, regardless of any provided expected-response-type. According to the HTTP RFC Status Code Definitions, there are many statuses that mandate that a response must not contain a message-body (for example, 204 No Content). There are also cases where calls to the same URL might or might not return a response body. For example, the first request to an HTTP resource returns content, but the second does not (returning a 304 Not Modified). In all cases, however, the http_statusCode message header is populated. This can be used in some routing logic after the HTTP outbound gateway. You could also use a`<payload-type-router/>` to route messages with a ResponseEntity to a different flow than that used for responses with a body.
 * 
 * expected-response-type
 * 
 * Further to the preceding note about empty response bodies, if a response does contain a body, you must provide an appropriate expected-response-type attribute or, again, you receive a ResponseEntity with no body. The expected-response-type must be compatible with the (configured or default) HttpMessageConverter instances and the Content-Type header in the response. This can be an abstract class or even an interface (such as java.io.Serializable when you use Java serialization and Content-Type: application/x-java-serialized-object).
 * 
 * Starting with version 5.5, the HttpRequestExecutingMessageHandler exposes an extractResponseBody flag (which is true by default) to return just the response body, or to return the whole ResponseEntity as the reply message payload, independently of the provided expectedResponseType. If a body is not present in the ResponseEntity, this flag is ignored and the whole ResponseEntity is returned.
 * 
 * By using the path attribute in conjunction with the payload-expression attribute and the header element, you have a high degree of flexibility for mapping inbound request data.
 * 
 * In the following example configuration, an inbound channel adapter is configured to accept requests using the following URI:
 * 
 *    /first-name/{firstName}/last-name/{lastName}
 * 
 * When you use the payload-expression attribute, the {firstName} URI template variable maps to be the Message payload, while the {lastName} URI template variable maps to the lname message header, as defined in the following example:
 * 
 *   <int-http:inbound-channel-adapter id="inboundAdapterWithExpressions"
 *       path="/first-name/{firstName}/last-name/{lastName}"
 *       channel="requests"
 *       payload-expression="#pathVariables.firstName">
 *       <int-http:header name="lname" expression="#pathVariables.lastName"/>
 *   </int-http:inbound-channel-adapter>
 * 
 * Since Spring Integration 3.0, in addition to the existing #pathVariables and #requestParams variables being available in payload and header expressions, we added other useful expression variables:
 *   
 *   #requestParams: The MultiValueMap from the ServletRequest parameterMap.
 *
 *    #pathVariables: The Map from URI Template placeholders and their values.
 *
 *    #matrixVariables: The Map of MultiValueMap according to the Spring MVC Specification. Note that #matrixVariables requires Spring MVC 3.2 or higher.
 *
 *    #requestAttributes: The org.springframework.web.context.request.RequestAttributes associated with the current request.
 *
 *    #requestHeaders: The org.springframework.http.HttpHeaders object from the current request.
 *
 *    #cookies: The Map<String, Cookie> of javax.servlet.http.Cookie instances from the current request.
 * 
 * Note that all these values (and others) can be accessed within expressions in the downstream message flow through the ThreadLocal org.springframework.web.context.request.RequestAttributes variable, if that message flow is single-threaded and lives within the request thread. The following example configures a transformer that uses an expression attribute:
 * 
 * <int-:transformer
    expression="T(org.springframework.web.context.request.RequestContextHolder).
                  requestAttributes.request.queryString"/>
 * 
 * Outbound
 * 
 * To configure the outbound gateway, you can use the namespace support. The following code snippet shows the available configuration options for an outbound HTTP gateway:
 *
 *  <int-http:outbound-gateway id="example"
 *      request-channel="requests"
 *      url="http://localhost/test"
 *      http-method="POST"
 *      extract-request-payload="false"
 *      expected-response-type="java.lang.String"
 *      charset="UTF-8"
 *      request-factory="requestFactory"
 *      reply-timeout="1234"
 *      reply-channel="replies"/>
 *  
 * Most importantly, notice that the 'http-method' and 'expected-response-type' attributes are provided. Those are two of the most commonly configured values. The default http-method is POST, and the default response type is null. With a null response type, the payload of the reply Message contains the ResponseEntity, as long as its HTTP status is a success (non-successful status codes throw exceptions). If you expect a different type, such as a String, provide that as a fully-qualified class name (java.lang.String in the preceding example). See also the note about empty response bodies in HTTP Outbound Components.
 * 
 * Beginning with Spring Integration 2.2, you can also determine the HTTP method dynamically by using SpEL and the http-method-expression attribute. Note that this attribute is mutually exclusive with http-method. You can also use the expected-response-type-expression attribute instead of expected-response-type and provide any valid SpEL expression that determines the type of the response. The following configuration example uses expected-response-type-expression:
 * 
 * <int-http:outbound-gateway id="example"
    request-channel="requests"
    url="http://localhost/test"
    http-method-expression="headers.httpMethod"
    extract-request-payload="false"
    expected-response-type-expression="payload"
    charset="UTF-8"
    request-factory="requestFactory"
    reply-timeout="1234"
    reply-channel="replies"/>
 * 
 * If your outbound adapter is to be used in a unidirectional way, you can use an outbound-channel-adapter instead. This means that a successful response executes without sending any messages to a reply channel. In the case of any non-successful response status code, it throws an exception. The configuration looks very similar to the gateway, as the following example shows:
 * 
 * <int-http:outbound-channel-adapter id="example"
    url="http://localhost/example"
    http-method="GET"
    channel="requests"
    charset="UTF-8"
    extract-payload="false"
    expected-response-type="java.lang.String"
    request-factory="someRequestFactory"
    order="3"
    auto-startup="false"/>
 * 
 * To specify the URL, you can use either the 'url' attribute or the 'url-expression' attribute. The 'url' attribute takes a simple string (with placeholders for URI variables, as described below). The 'url-expression' is a SpEL expression, with the Message as the root object, which enables dynamic urls. The URL that results from the expression evaluation can still have placeholders for URI variables.
 * 
 * Timeout Handling
 * 
 * In the context of HTTP components, there are two timing areas that have to be considered:
 * 
 *     Timeouts when interacting with Spring Integration Channels
 * 
 *     Timeouts when interacting with a remote HTTP server
 *  
 * the components interact with message channels, for which timeouts can be specified. For example, an HTTP Inbound Gateway forwards messages received from connected HTTP Clients to a message channel (which uses a request timeout) and consequently the HTTP Inbound Gateway receives a reply message from the reply channel (which uses a reply timeout) that is used to generate the HTTP Response.
 * 
 * For outbound endpoints, we need to consider how timing works while interacting with the remote server.
 * 
 * You may want to configure the HTTP related timeout behavior, when making active HTTP requests by using the HTTP outbound gateway or the HTTP outbound channel adapter. In those instances, these two components use Spring’s RestTemplate support to execute HTTP requests.
 * 
 * To configure timeouts for the HTTP outbound gateway and the HTTP outbound channel adapter, you can either reference a RestTemplate bean directly (by using the rest-template attribute) or you can provide a reference to a ClientHttpRequestFactory bean (by using the request-factory attribute). Spring provides the following implementations of the ClientHttpRequestFactory interface:
 * 
 *   SimpleClientHttpRequestFactory: Uses standard J2SE facilities for making HTTP Requests
 * 
 *   HttpComponentsClientHttpRequestFactory: Uses Apache HttpComponents HttpClient (since Spring 3.1)
 * 
 * If you do not explicitly configure the request-factory or rest-template attribute, a default RestTemplate (which uses a SimpleClientHttpRequestFactory) is instantiated.
 * 
 * HTTP Outbound Gateway
 * 
 * For the HTTP Outbound Gateway, the XML Schema defines only the reply-timeout. The reply-timeout maps to the sendTimeout property of the org.springframework.integration.http.outbound.HttpRequestExecutingMessageHandler class. More precisely, the property is set on the extended AbstractReplyProducingMessageHandler class, which ultimately sets the property on the MessagingTemplate.
 * 
 * The value of the sendTimeout property defaults to "-1" and will be applied to the connected MessageChannel. This means, that depending on the implementation, the Message Channel’s send method may block indefinitely. Furthermore, the sendTimeout property is only used, when the actual MessageChannel implementation has a blocking send (such as 'full' bounded QueueChannel).
 * 
 * HTTP Inbound Gateway
 * 
 * For the HTTP inbound gateway, the XML Schema defines the request-timeout attribute, which is used to set the requestTimeout property on the HttpRequestHandlingMessagingGateway class (on the extended MessagingGatewaySupport class). You can also use the reply-timeout attribute to map to the replyTimeout property on the same class.
 * 
 * The default for both timeout properties is 1000ms (one thousand milliseconds or one second). Ultimately, the request-timeout property is used to set the sendTimeout on the MessagingTemplate instance. The replyTimeout property, on the other hand, is used to set the receiveTimeout property on the MessagingTemplate instance.
 * 
 *  To simulate connection timeouts, you can connect to a non-routable IP address, such as 10.255.255.10. 
 * 
 */
public class Application {
    
    @EnableAutoConfiguration
    @Configuration
    @IntegrationComponentScan
    @EnableIntegrationGraphController
    @Slf4j
    public static class HttpBasicIntegrationApplication {
        public static void main(String[] args) throws Exception {

            log.info("--");
            new SpringApplicationBuilder()
                      .sources(HttpBasicIntegrationApplication.class,TestStringChannels.class,ChannelConfiguration.class,
                      HttpBasicIntegrationConfig.class,UppercaserEndpoint.class
                                          )
                      .properties("spring.config.location=optional:classpath:com/example/democloudstreamwebfux/intergration/http/basic/")
                      .run("--management.endpoints.web.exposure.include=*","--spring.main.lazy-initialization=false" 
                                  ,"--logging.level.root=INFO" 
                                  ,"--logging.level.org.springframework.retry.support.RetryTemplate=DEBUG"
                                  ,"--spring.cloud.stream.defaultBinder=rabbit");
        }
    }

    @Component(value = "uppercaserEndpoint")
    public static class UppercaserEndpoint {

        public Message<?> uppercase(Message<String> msg) {
            return MessageBuilder
                            .withPayload(msg.getPayload().toUpperCase())
                            .setHeader("http_statusCode", HttpStatus.OK)
                            .build() ;
        }

    }

    @Configuration
    @Slf4j
    public static class HttpBasicIntegrationConfig {

        @Bean
        public ExpressionParser parser() {
            return new SpelExpressionParser();
        }

        @Bean
        public HeaderMapper<HttpHeaders> headerMapper() {
            return new DefaultHttpHeaderMapper();
        }

        /**
         * The flow works as follows:
         * 
         * from(inbound()): Get messages received by the HTTP Inbound Gateway.
         * 
         * channel(“httpRequestChannel”): Register a new DirectChannel bean and send the message received to it.
         * 
         * handle(“personEndpoint”, “get”): Messages sent to the previous channel will be consumed by our personEndpoint bean, invoking its get method.
         * 
         * Since we are using a gateway, the response of the personEndpoint will be sent back to the client.
         * 
         * payload-expression ="new RequestDTO(
         *                         #pathVariables.product,
         *                         #pathVariables.id,
         *                         #requestParams['optionalParam'],
         *                         headers.get('headerKey'),
         *                         body)" 
         * 
         * Expression payloadExpression = new SpelExpressionParser().parseExpression("...");
         * 
         */
        @Bean
        public MessagingGatewaySupport inbound() {
            HttpRequestHandlingMessagingGateway gateway = 
                                                    new HttpRequestHandlingMessagingGateway(true);

            gateway.setRequestMapping(mapping(new HttpMethod[]{HttpMethod.POST},"/foo"));   
            gateway.setStatusCodeExpression(parser().parseExpression("T(org.springframework.http.HttpStatus).OK"));  
            gateway.setHeaderMapper(headerMapper());                                          
            gateway.setRequestPayloadTypeClass(String.class);    
            // gateway.setRequestChannel(httpRequestChannel());
            return gateway ;
        }

        public RequestMapping mapping(HttpMethod[] method,String... path) {
            RequestMapping requestMapping = new RequestMapping() ;
            requestMapping.setPathPatterns(path);
            requestMapping.setMethods(method);
            requestMapping.setConsumes("application/json");
            requestMapping.setProduces("application/json");
            return requestMapping;
        }

        @Bean
        public IntegrationFlow inboundFlow() {
            return IntegrationFlows
                                .from(inbound())
                                .channel("httpRequestChannel")
                                .handle("uppercaserEndpoint", "uppercase")
                                .get();
        }

        @Bean
        @Order(30)
        public ApplicationRunner runner( ) {

            return args -> {
                RestTemplate restTemplate = new RestTemplate();

                HttpHeaders headers = new HttpHeaders();
                headers.setAccept(Arrays.asList(MediaType.APPLICATION_JSON));
                headers.setContentType(MediaType.APPLICATION_JSON); 
                
                HttpEntity<String> request = new HttpEntity<>("Hiiiiiiiiiiiiiiiiiiii",headers);
                

                ResponseEntity<String> response = 
                        restTemplate.exchange("http://localhost:8080/foo",HttpMethod.POST, request, String.class);

                log.info("response: {}",response.getBody());

            };

        }
 
    }



}
